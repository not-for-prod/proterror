// protoc-gen-ProtError generates gRPC-aware error helpers for proto messages annotated with error options.
package main

import (
	"flag"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"

	"github.com/not-for-prod/proterror/proterror"
)

var (
	codesPackage  = protogen.GoImportPath("google.golang.org/grpc/codes")
	statusPackage = protogen.GoImportPath("google.golang.org/grpc/status")
)

func main() {
	// Configure protogen to honor flags and then generate outputs for all requested files.
	protogen.Options{
		ParamFunc: flag.CommandLine.Set,
	}.Run(
		func(p *protogen.Plugin) error {
			p.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

			for _, f := range p.Files {
				if f.Generate {
					generate(p, f)
				}
			}

			return nil
		},
	)
}

// generate emits ProtError implementations for messages annotated with ProtError options.
func generate(p *protogen.Plugin, f *protogen.File) {
	var g *protogen.GeneratedFile

	for _, msg := range f.Messages {
		opts, ok := msg.Desc.Options().(*descriptorpb.MessageOptions)
		if !ok {
			continue
		}

		if proto.HasExtension(opts, proterror.E_Options) {
			if g == nil {
				g = p.NewGeneratedFile(f.GeneratedFilenamePrefix+".pb.proterror.go", f.GoImportPath)
				g.P("// Code generated by protoc-gen-ProtError. DO NOT EDIT.")
				g.P()
				g.P("package ", f.GoPackageName)
				g.P()
			}

			g.P("// ==================================================================================== //")
			g.P("// ProtError implementation for message: ", msg.Desc.Name())
			g.P("// ==================================================================================== //")
			g.P()
			g.P("func (x *", msg.Desc.Name(), ") Error() string {")
			g.P("return \"", msg.Desc.Name(), "\"")
			g.P("}")
			g.P()
			g.P("func (x *", msg.Desc.Name(), ") Is(err error) bool {")
			g.P("_, ok := err.(*", msg.Desc.Name(), ")")
			g.P("return ok")
			g.P("}")
			g.P()

			ext, ok := proto.GetExtension(opts, proterror.E_Options).(*proterror.MessageOptions)
			if ok {
				g.P("func (x *", msg.Desc.Name(), ") Code() codes.Code {")
				num := int32(ext.Code)
				g.P("return ", codesPackage.Ident("Code"), "(", num, ")")
				g.P("}")
				g.P()
			}

			g.P("func (x *", msg.Desc.Name(), ") Status() *", statusPackage.Ident("Status"), " {")
			g.P("st, _ := ", statusPackage.Ident("New"), "(x.Code(), x.Error()).WithDetails(x)")
			g.P("return st")
			g.P("}")
			g.P()
		}
	}
}
